package jee.service;

import java.security.Key;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.Map;

import javax.annotation.PostConstruct;
import javax.crypto.SecretKey;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import org.apache.commons.collections.map.HashedMap;
import org.apache.shiro.codec.Hex;
import org.apache.shiro.crypto.SecureRandomNumberGenerator;
import org.apache.shiro.crypto.hash.Sha512Hash;
import org.apache.shiro.util.ByteSource;

import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.impl.crypto.MacProvider;
import jee.entity.User;

//Security class for password manage an application scoped cdi bean(one lifespan accross application
@ApplicationScoped
public class SecurityUtil {
	@Inject QueryService queryService;
	
	public static final String HASHED_PASSWORD_KEY = "hashedPassword";
	public static final String SALT_KEY = "salt";
	public static final String BEARER = "Bearer";
	//security key variable
	//extends key class
	private SecretKey securityKey;
	//convinience method
	
	//this will keep the same key value stored and can be accesed elsewhere rather then always generating a new key whenever the method
	//generateKey() is called
	//since application scoped this method will be invoked once and key created once
	@PostConstruct
	private void init() {
		securityKey = generateKey();
	}
	
	public Date toDate(LocalDateTime localDateTime) {
		return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
	}
	//this one when you want to check password match to verify and compare
	//recieves the stored password a salt and the user input password
	public boolean passwordMatch(String dbStoredHashedPassword, String saltText, String clearTextPassword) {
		//gets the byte source from the salt
		ByteSource salt = ByteSource.Util.bytes(Hex.decode(saltText));
		//creates the hashedpassword of what the user put in using the salt
		String hashedPassword = hashAndSaltPassword(clearTextPassword, salt);
		//checks if the hashed passwords match
		return hashedPassword.equals(dbStoredHashedPassword);
	}
	//takes user clear text password and we get a salt which is generated byte source
	//call when you want to hash a password
	public Map<String, String> hashPassword(String clearTextPassword){
		//we get a salt which is generated byte source
		ByteSource salt = getSalt();
		//create a map that will take the hashed password then the salt we use the hashAndSalt method for the password
		Map<String, String> credMap = new HashedMap();
		credMap.put(HASHED_PASSWORD_KEY, hashAndSaltPassword(clearTextPassword, salt));
		credMap.put(SALT_KEY, salt.toHex());
		//returns a map so we save the same salt
		return credMap;
	}
	//takes clear text password and the salt  then use the shiro api to hash it with the iterations then converts to hex
	//this returns a string of the password
	private String hashAndSaltPassword(String clearTextPassword, ByteSource salt) {
		return new Sha512Hash(clearTextPassword, salt, 2000000).toHex();
	}
	
	private ByteSource getSalt() {
		return new SecureRandomNumberGenerator().nextBytes();
	}
	
	public boolean authenticateUser(String email, String password) {
//		//uses the passwordMatch method to hash the input password and check if it matches the users input password after being hashed
//		//the method takes the stored hashed password the salt and the newly input password
		User user = queryService.findUserByEmail(email);
		if(user == null) {
			return false;
		}
		return passwordMatch(user.getPassword(), user.getSalt(), password);
	//	return queryService.authenticateUser(email, password);
	}
	//the key we sign the jjwt is the same key we need to pass it
	private SecretKey generateKey() {
		//issue with this implementation will generate a new key each time
		return MacProvider.generateKey(SignatureAlgorithm.HS512);
	}

	/**
	 * @return the securityKey
	 */
	public SecretKey getSecurityKey() {
		return securityKey;
	}

}


